local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")

local LoadingGui = Instance.new("ScreenGui")
LoadingGui.Name = "MangaHubLoading"
LoadingGui.ResetOnSpawn = false
LoadingGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
LoadingGui.Parent = CoreGui

local LoadingFrame = Instance.new("Frame")
LoadingFrame.Size = UDim2.fromScale(1, 1)
LoadingFrame.Position = UDim2.fromScale(0, 0)
LoadingFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
LoadingFrame.BorderSizePixel = 0
LoadingFrame.Parent = LoadingGui

local Container = Instance.new("Frame")
Container.Size = UDim2.fromOffset(400, 200)
Container.Position = UDim2.fromScale(0.5, 0.5)
Container.AnchorPoint = Vector2.new(0.5, 0.5)
Container.BackgroundTransparency = 1
Container.Parent = LoadingFrame

local Title = Instance.new("TextLabel")
Title.Size = UDim2.fromScale(1, 0.2)
Title.Position = UDim2.fromScale(0, 0)
Title.BackgroundTransparency = 1
Title.Text = "MANGA HUB"
Title.TextColor3 = Color3.fromRGB(255, 140, 0)
Title.TextScaled = true
Title.Font = Enum.Font.GothamBold
Title.Parent = Container

local Subtitle = Instance.new("TextLabel")
Subtitle.Size = UDim2.fromScale(1, 0.15)
Subtitle.Position = UDim2.fromScale(0, 0.22)
Subtitle.BackgroundTransparency = 1
Subtitle.Text = "BBB Brasil V4.2"
Subtitle.TextColor3 = Color3.fromRGB(200, 200, 200)
Subtitle.TextSize = 18
Subtitle.Font = Enum.Font.Gotham
Subtitle.Parent = Container

local ProgressBarBg = Instance.new("Frame")
ProgressBarBg.Size = UDim2.fromOffset(380, 8)
ProgressBarBg.Position = UDim2.fromScale(0.5, 0.6)
ProgressBarBg.AnchorPoint = Vector2.new(0.5, 0.5)
ProgressBarBg.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
ProgressBarBg.BorderSizePixel = 0
ProgressBarBg.Parent = Container

local ProgressBarBgCorner = Instance.new("UICorner")
ProgressBarBgCorner.CornerRadius = UDim.new(1, 0)
ProgressBarBgCorner.Parent = ProgressBarBg

local ProgressBar = Instance.new("Frame")
ProgressBar.Size = UDim2.fromOffset(0, 8)
ProgressBar.Position = UDim2.fromScale(0, 0)
ProgressBar.BackgroundColor3 = Color3.fromRGB(255, 140, 0)
ProgressBar.BorderSizePixel = 0
ProgressBar.Parent = ProgressBarBg

local ProgressBarCorner = Instance.new("UICorner")
ProgressBarCorner.CornerRadius = UDim.new(1, 0)
ProgressBarCorner.Parent = ProgressBar

local ProgressText = Instance.new("TextLabel")
ProgressText.Size = UDim2.fromScale(1, 0.15)
ProgressText.Position = UDim2.fromScale(0, 0.75)
ProgressText.BackgroundTransparency = 1
ProgressText.Text = "0%"
ProgressText.TextColor3 = Color3.fromRGB(255, 255, 255)
ProgressText.TextSize = 24
ProgressText.Font = Enum.Font.GothamBold
ProgressText.Parent = Container

local StatusText = Instance.new("TextLabel")
StatusText.Size = UDim2.fromScale(1, 0.1)
StatusText.Position = UDim2.fromScale(0, 0.88)
StatusText.BackgroundTransparency = 1
StatusText.Text = "Inicializando..."
StatusText.TextColor3 = Color3.fromRGB(150, 150, 150)
StatusText.TextSize = 14
StatusText.Font = Enum.Font.Gotham
StatusText.Parent = Container

local function animateLoading()
    local startTime = tick()
    local duration = 15
    local messages = {
        {progress = 0, text = "Inicializando..."},
        {progress = 15, text = "Carregando interface..."},
        {progress = 35, text = "Conectando aos servidores..."},
        {progress = 55, text = "Preparando sistema de vota√ß√£o..."},
        {progress = 75, text = "Configurando scripts..."},
        {progress = 90, text = "Finalizando..."},
        {progress = 100, text = "Completo!"}
    }
    
    local currentMessageIndex = 1
    
    while true do
        local elapsed = tick() - startTime
        local progress = math.min((elapsed / duration) * 100, 100)
        
        ProgressBar.Size = UDim2.fromOffset((progress / 100) * 380, 8)
        ProgressText.Text = math.floor(progress) .. "%"
        
        if currentMessageIndex <= #messages and progress >= messages[currentMessageIndex].progress then
            StatusText.Text = messages[currentMessageIndex].text
            currentMessageIndex = currentMessageIndex + 1
        end
        
        if progress >= 100 then
            break
        end
        
        task.wait()
    end
    
    task.wait(0.5)
    
    local tweenInfo = TweenInfo.new(0.8, Enum.EasingStyle.Quint, Enum.EasingDirection.In)
    local tween = TweenService:Create(LoadingFrame, tweenInfo, {Position = UDim2.fromScale(0, 1)})
    tween:Play()
    
    tween.Completed:Connect(function()
        LoadingGui:Destroy()
    end)
end

task.spawn(animateLoading)

task.wait(15)

local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MangaHubMinimizeButton"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui

local Button = Instance.new("TextButton")
Button.Size = isMobile and UDim2.fromOffset(30, 30) or UDim2.fromOffset(50, 50)
Button.Position = UDim2.new(0, 50, 0, 50)
Button.BackgroundColor3 = Color3.fromRGB(255, 140, 0)
Button.Text = "ü•≠"
Button.TextScaled = true
Button.TextColor3 = Color3.fromRGB(255, 255, 255)
Button.BorderSizePixel = 0
Button.AutoButtonColor = true
Button.AnchorPoint = Vector2.new(0.5, 0.5)
Button.Parent = ScreenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1,0)
UICorner.Parent = Button

local dragging, dragInput, dragStart, startPos
local function update(input)
    local delta = input.Position - dragStart
    Button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = Button.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

getgenv().MangaHubWindow = nil
local minimized = false
Button.MouseButton1Click:Connect(function()
    if getgenv().MangaHubWindow then
        if minimized then
            getgenv().MangaHubWindow:Show()
            getgenv().MangaHubWindow.Frame.Visible = true
            minimized = false
        else
            getgenv().MangaHubWindow:Minimize()
            getgenv().MangaHubWindow.Frame.Visible = false
            minimized = true
        end
    end
end)

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local windowSize = isMobile and UDim2.fromOffset(400, 300) or UDim2.fromOffset(580, 460)
local tabWidth = isMobile and 120 or 160

local Window = Fluent:CreateWindow({
    Title = "manga hub/V4.2/Brasil",
    SubTitle = "BBB Brasil",
    TabWidth = tabWidth,
    Size = windowSize,
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

getgenv().MangaHubWindow = Window

local Tabs = {
    Main = Window:AddTab({ Title = "Vota√ß√£o", Icon = "check-square" }),
    Player = Window:AddTab({ Title = "Player", Icon = "user" }),
    Teleport = Window:AddTab({ Title = "Teleport", Icon = "map-pin" }),
    Evento = Window:AddTab({ Title = "Evento", Icon = "star" })
}

local Options = Fluent.Options

local selectedPlayer = nil
local votingEnabled = false
local votingCoroutine = nil
local playerList = {}

local function getPlayerList()
    local list = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            table.insert(list, player.Name)
        end
    end
    return list
end

local function votePlayer(playerName)
    task.spawn(function()
        local success, err = pcall(function()
            local args = {
                [1] = playerName,
                [2] = 5
            }
            ReplicatedStorage.Remotes:FindFirstChild("\240\159\140\131\240\159\145\139\240\159\154\135\226\152\132"):FireServer(unpack(args))
        end)
    end)
end

playerList = getPlayerList()
table.insert(playerList, 1, Players.LocalPlayer.Name)

local Dropdown = Tabs.Main:AddDropdown("PlayerDropdown", {
    Title = "Selecionar Jogador",
    Values = playerList,
    Multi = false,
    Default = 1,
})

Dropdown:OnChanged(function(Value)
    selectedPlayer = Value
end)

Tabs.Main:AddButton({
    Title = "Atualizar Lista",
    Description = "Atualiza a lista de jogadores",
    Callback = function()
        playerList = getPlayerList()
        table.insert(playerList, 1, Players.LocalPlayer.Name)
        Dropdown:SetValues(playerList)
        Fluent:Notify({
            Title = "Lista Atualizada",
            Content = "A lista de jogadores foi atualizada!",
            Duration = 3
        })
    end
})

local Toggle = Tabs.Main:AddToggle("VoteToggle", {Title = "Votar nesta pessoa( muito melhorado!! )", Default = false})

Toggle:OnChanged(function()
    votingEnabled = Options.VoteToggle.Value
    
    if votingEnabled then
        if not selectedPlayer or selectedPlayer == "" then
            Fluent:Notify({
                Title = "Erro",
                Content = "Selecione um jogador primeiro!",
                Duration = 5
            })
            Options.VoteToggle:SetValue(false)
            return
        end
        
        votingCoroutine = coroutine.create(function()
            while votingEnabled do
                if selectedPlayer and selectedPlayer ~= "" then
                    votePlayer(selectedPlayer)
                end
                task.wait()
            end
        end)
        
        coroutine.resume(votingCoroutine)
        
        Fluent:Notify({
            Title = "Vota√ß√£o Iniciada",
            Content = "Votando em: " .. selectedPlayer,
            Duration = 3
        })
    else
        votingEnabled = false
        Fluent:Notify({
            Title = "Vota√ß√£o Parada",
            Content = "A vota√ß√£o foi interrompida!",
            Duration = 3
        })
    end
end)

Tabs.Main:AddParagraph({
    Title = "Informa√ß√µes",
    Content = "Voc√™ deve usar isso em pessoas no pared√£o.\n\nQuando ativado em uma pessoa no pared√£o, tem 95% de chance da pessoa ir embora, e 5% dela n√£o ir."
})

local velocidadeValue = 16
local speedEnabled = false
local speedCoroutine = nil

Tabs.Player:AddInput("Velocidade", {
    Title = "Velocidade",
    Default = "16",
    Placeholder = "Digite a velocidade",
    Numeric = true,
    Callback = function(Value)
        velocidadeValue = tonumber(Value) or 16
    end
})

Tabs.Player:AddToggle("PegarVelocidade", {
    Title = "Pegar Velocidade",
    Default = false,
    Callback = function(Value)
        speedEnabled = Value
        
        if speedEnabled then
            speedCoroutine = coroutine.create(function()
                while speedEnabled do
                    if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
                        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = velocidadeValue
                    end
                    task.wait()
                end
            end)
            
            coroutine.resume(speedCoroutine)
            
            Fluent:Notify({
                Title = "Velocidade Ativada",
                Content = "Velocidade definida para: " .. velocidadeValue,
                Duration = 3
            })
        else
            speedEnabled = false
            if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
                game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
            end
            Fluent:Notify({
                Title = "Velocidade Desativada",
                Content = "Velocidade voltou ao normal!",
                Duration = 3
            })
        end
    end
})

local selectedTpPlayer = nil
local tpPlayerList = {}

local TpDropdown = Tabs.Teleport:AddDropdown("TpPlayerDropdown", {
    Title = "Players",
    Values = getPlayerList(),
    Multi = false,
    Default = 1,
})

TpDropdown:OnChanged(function(Value)
    selectedTpPlayer = Value
end)

Tabs.Teleport:AddButton({
    Title = "Atualizar Lista",
    Description = "Atualiza a lista de jogadores",
    Callback = function()
        tpPlayerList = getPlayerList()
        TpDropdown:SetValues(tpPlayerList)
        Fluent:Notify({
            Title = "Lista Atualizada",
            Content = "A lista de jogadores foi atualizada!",
            Duration = 3
        })
    end
})

Tabs.Teleport:AddButton({
    Title = "TP para esse player",
    Description = "Teleporta voc√™ para o jogador selecionado",
    Callback = function()
        if not selectedTpPlayer or selectedTpPlayer == "" then
            Fluent:Notify({
                Title = "Erro",
                Content = "Selecione um jogador primeiro!",
                Duration = 5
            })
            return
        end
        
        local targetPlayer = Players:FindFirstChild(selectedTpPlayer)
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
                Fluent:Notify({
                    Title = "Teleportado",
                    Content = "Voc√™ foi teleportado para " .. selectedTpPlayer .. "!",
                    Duration = 3
                })
            end
        else
            Fluent:Notify({
                Title = "Erro",
                Content = "Jogador n√£o encontrado ou sem personagem!",
                Duration = 5
            })
        end
    end
})

local autoJogoEnabled = false
local autoJogoCoroutine = nil
local detectionPart = nil

local function limparDetectionPart()
    if detectionPart then
        detectionPart:Destroy()
        detectionPart = nil
    end
end

local function encontrarSpawnDoPlayer()
    local minigame = game.Workspace:FindFirstChild("MinigameCrazykitchen")
    if not minigame then
        return nil
    end
    
    local spawns = minigame:FindFirstChild("Spawns")
    if not spawns then
        return nil
    end
    
    for _, child in pairs(spawns:GetChildren()) do
        if child:IsA("BasePart") and child.Name == Players.LocalPlayer.Name then
            return child
        end
    end
    
    return nil
end

local function criarDetectionPart()
    limparDetectionPart()
    
    if not game.Players.LocalPlayer.Character then return nil end
    local hrp = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local part = Instance.new("Part")
    part.Name = "FruitDetectionPart"
    part.Size = Vector3.new(1000, 1, 1000)
    part.Transparency = 0.5
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromRGB(0, 100, 255)
    part.CFrame = hrp.CFrame * CFrame.new(0, 4, 0)
    part.Parent = game.Workspace
    
    detectionPart = part
    return part
end

local frutas = {
    "banana", "orange", "apple", "grape", "watermelon", "strawberry", 
    "pineapple", "mango", "cherry", "lemon", "peach", "pear", "kiwi",
    "Banana", "Orange", "Apple", "Grape", "Watermelon", "Strawberry",
    "Pineapple", "Mango", "Cherry", "Lemon", "Peach", "Pear", "Kiwi"
}

local frutasIgnoradas = {"bomb", "Bomb", "BOMB"}

local frutasProcessadas = {}

local function ehFruta(nome)
    for _, bomba in pairs(frutasIgnoradas) do
        if string.find(string.lower(nome), string.lower(bomba)) then
            return false
        end
    end
    
    for _, fruta in pairs(frutas) do
        if string.find(string.lower(nome), string.lower(fruta)) then
            return true
        end
    end
    return false
end

local function baterNaFruta()
    task.spawn(function()
        local minigame = game.Workspace:FindFirstChild("MinigameCrazykitchen")
        if minigame then
            local remote = minigame:FindFirstChild("üçé2")
            if remote and remote:IsA("RemoteEvent") then
                remote:FireServer()
            end
        end
    end)
end

local function atualizarPosicaoDetectionPart()
    if not detectionPart then return end
    if not game.Players.LocalPlayer.Character then return end
    local hrp = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    detectionPart.CFrame = hrp.CFrame * CFrame.new(0, 4, 0)
end

local function conectarDeteccaoDeFruta(fruta)
    if not fruta:IsA("BasePart") then return end
    if frutasProcessadas[fruta] then return end
    
    local connection
    connection = fruta.Touched:Connect(function(hit)
        if not autoJogoEnabled then
            if connection then connection:Disconnect() end
            return
        end
        
        if hit == detectionPart and not frutasProcessadas[fruta] then
            frutasProcessadas[fruta] = true
            baterNaFruta()
            
            if connection then
                connection:Disconnect()
            end
        end
    end)
    
    fruta.AncestryChanged:Connect(function()
        if not fruta:IsDescendantOf(game) then
            frutasProcessadas[fruta] = nil
            if connection then
                connection:Disconnect()
            end
        end
    end)
end

Tabs.Evento:AddToggle("AutoJogoToggle", {
    Title = "(BETA) Auto Jogo de Bater em Fruta",
    Default = false,
    Callback = function(Value)
        autoJogoEnabled = Value
        
        if autoJogoEnabled then
            local minigame = game.Workspace:FindFirstChild("MinigameCrazykitchen")
            
            if not minigame then
                Fluent:Notify({
                    Title = "Erro",
                    Content = "O mapa n√£o est√° spawnado.",
                    Duration = 5
                })
                Options.AutoJogoToggle:SetValue(false)
                return
            end
            
            local spawnPart = encontrarSpawnDoPlayer()
            
            if not spawnPart then
                Fluent:Notify({
                    Title = "Erro",
                    Content = "Seu spawn n√£o foi encontrado!",
                    Duration = 5
                })
                Options.AutoJogoToggle:SetValue(false)
                return
            end
            
            Fluent:Notify({
                Title = "Auto Jogo Ativado",
                Content = "Automaticamente fazendo a prova...",
                Duration = 3
            })
            
            criarDetectionPart()
            
            spawnPart.ChildAdded:Connect(function(child)
                if not autoJogoEnabled then return end
                
                if ehFruta(child.Name) then
                    task.wait(0.1)
                    conectarDeteccaoDeFruta(child)
                end
            end)
            
            for _, child in pairs(spawnPart:GetChildren()) do
                if ehFruta(child.Name) then
                    conectarDeteccaoDeFruta(child)
                end
            end
            
            autoJogoCoroutine = coroutine.create(function()
                while autoJogoEnabled do
                    atualizarPosicaoDetectionPart()
                    task.wait(0.1)
                end
            end)
            
            coroutine.resume(autoJogoCoroutine)
        else
            autoJogoEnabled = false
            limparDetectionPart()
            Fluent:Notify({
                Title = "Auto Jogo Desativado",
                Content = "O auto jogo foi desativado!",
                Duration = 3
            })
        end
    end
})

Tabs.Evento:AddParagraph({
    Title = "Informa√ß√µes",
    Content = "Esta fun√ß√£o automaticamente joga o minigame de bater em frutas.\n\nCria uma part azul ao seu redor que detecta frutas."
})

local autoLavaEnabled = false
local autoLavaCoroutine = nil
local bodyPosition = nil
local frozenPosition = nil

local function congelarPlayer()
    if not game.Players.LocalPlayer.Character then return end
    local hrp = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    frozenPosition = hrp.CFrame.Position
    
    if not bodyPosition then
        bodyPosition = Instance.new("BodyPosition")
        bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bodyPosition.D = 1000
        bodyPosition.P = 10000
        bodyPosition.Parent = hrp
    end
    
    bodyPosition.Position = frozenPosition
end

local function descongelarPlayer()
    if bodyPosition then
        bodyPosition:Destroy()
        bodyPosition = nil
    end
    frozenPosition = nil
end

local function verificarEDestruirBolaDeFogo()
    local lavaModel = game.Workspace:FindFirstChild("Lava")
    if not lavaModel then return end
    
    for _, obj in pairs(lavaModel:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name == "BolaDeFogo" then
            obj:Destroy()
        end
    end
end

Tabs.Evento:AddToggle("AutoLavaToggle", {
    Title = "(BETA) Auto Jogo de Lava",
    Default = false,
    Callback = function(Value)
        autoLavaEnabled = Value
        
        if autoLavaEnabled then
            Fluent:Notify({
                Title = "Auto Lava Ativado",
                Content = "Voc√™ est√° congelado e protegido!",
                Duration = 3
            })
            
            congelarPlayer()
            
            autoLavaCoroutine = coroutine.create(function()
                while autoLavaEnabled do
                    verificarEDestruirBolaDeFogo()
                    
                    if frozenPosition and game.Players.LocalPlayer.Character then
                        local hrp = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if hrp and bodyPosition then
                            bodyPosition.Position = frozenPosition
                        end
                    end
                    
                    task.wait(2^-1074)
                end
            end)
            
            coroutine.resume(autoLavaCoroutine)
        else
            autoLavaEnabled = false
            descongelarPlayer()
            Fluent:Notify({
                Title = "Auto Lava Desativado",
                Content = "Voc√™ pode se mover novamente!",
                Duration = 3
            })
        end
    end
})

Tabs.Evento:AddParagraph({
    Title = "Informa√ß√µes Auto Lava",
    Content = "Esta fun√ß√£o:\n- Te congela no lugar\n- Deleta automaticamente BolaDeFogo do model Lava\n- Voc√™ fica flutuando se o ch√£o sumir"
})

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("VotingSystem")
SaveManager:SetFolder("VotingSystem/config")

Window:SelectTab(1)

Fluent:Notify({
    Title = "Sistema de Vota√ß√£o",
    Content = "Script carregado com sucesso!",
    Duration = 5
})

print("seloko, compensa dmsss")



